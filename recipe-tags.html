---
layout: null
permalink: /recipe-tags/
---
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>{{ page.title }} - {{ site.title }}</title>
  <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
</head>
  
<body>
  
  {% include header %}

  <main class="wrap">

    <div id="tag-buttons" class="tags" style="padding: 0 0 15px;"></div>

    <ul id="tag-results" class="recipe-list"></ul>
  
  </main>

  {% include footer %}

  <script>
  document.addEventListener('DOMContentLoaded', function () {
  const tagButtons = document.getElementById('tag-buttons');
  const results = document.getElementById('tag-results');
  let recipes = [];
  let activeTags = new Set(); // store all currently selected tags

  const indexUrl = '{{ "/recipes.json" | relative_url }}';
  const baseUrl = '{{ "/recipe-tags/" | relative_url }}';

  fetch(indexUrl)
    .then(r => { if (!r.ok) throw new Error('Fetch failed'); return r.json(); })
    .then(data => {
      recipes = data;
      renderTags();

      // Check URL params on load
      const params = new URLSearchParams(window.location.search);
      const tagsParam = params.get('tags'); // comma-separated tags
      if(tagsParam) {
        tagsParam.split(',').forEach(tag => activeTags.add(decodeURIComponent(tag)));
        filterByTags();
      }
    })
    .catch(err => console.error('Failed to load recipes.json', err));

  function renderTags() {
    const tagSet = new Set();
    recipes.forEach(r => (r.tags || []).forEach(tag => tagSet.add(tag)));
    [...tagSet].sort().forEach(tag => {
      const btn = document.createElement('button');
      btn.className = 'tag';
      btn.textContent = tag;
      btn.type = 'button';

      btn.onclick = () => {
        if(activeTags.has(tag)) activeTags.delete(tag); // toggle off
        else activeTags.add(tag); // toggle on

        updateURL();
        filterByTags();
      };

      tagButtons.appendChild(btn);
    });
  }

  function filterByTags() {
    results.innerHTML = '';

    if(activeTags.size === 0) return;

    const filtered = recipes.filter(r => {
      const rTags = r.tags || [];
      // AND logic: recipe must have all activeTags
      return [...activeTags].every(t => rTags.includes(t));
    });

    if(filtered.length === 0) {
      results.innerHTML = '<p>No recipes found matching selected tags.</p>';
    } else {
      filtered.forEach(r => {
        const li = document.createElement('li');
        li.innerHTML = `<a href="${r.url}">${r.title}</a>`;
        results.appendChild(li);
      });
    }

    highlightActiveTags();
  }

  function highlightActiveTags() {
    const buttons = tagButtons.querySelectorAll('.tag');
    buttons.forEach(btn => {
      if(activeTags.has(btn.textContent)) {
        btn.classList.add('active');   // selected → add active
      } else {
        btn.classList.remove('active'); // not selected → remove active
      }
    });
  }


  function updateURL() {
    const params = new URLSearchParams();
    if(activeTags.size > 0) {
      params.set('tags', [...activeTags].map(encodeURIComponent).join(','));
    }
    const newUrl = baseUrl + (params.toString() ? '?' + params.toString() : '');
    history.pushState({}, '', newUrl);
  }

  window.addEventListener('popstate', () => {
    const params = new URLSearchParams(window.location.search);
    activeTags = new Set();
    const tagsParam = params.get('tags');
    if(tagsParam) tagsParam.split(',').forEach(tag => activeTags.add(decodeURIComponent(tag)));
    filterByTags();
  });
});
</script>
